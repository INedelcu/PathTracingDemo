//#define ENABLE_TEMPORAL_ACCUMULATION
//#define ENABLE_CAMERA_MOTION_VECTORS

#include "UnityShaderVariables.cginc"
#include "GlobalResources.hlsl"
#include "Utils.hlsl"
#include "RayPayload.hlsl"

#pragma max_recursion_depth 1

// Input
float                           g_Zoom;
float                           g_AspectRatio;
uint                            g_FrameIndex;
TextureCube<float4>             g_EnvTex;
SamplerState                    sampler_g_EnvTex;
float4                          g_DirectionalLight;
float4                          g_DirectionalLightColor;
int                             g_UseDirectionalLight;
int                             g_DirectionalLightShadows;
float4x4                        g_PreviousViewProjection;

// Output
RWTexture2D<float4>             g_Radiance;
RWTexture2D<float4>             g_RadianceHistory;

[shader("raygeneration")]
void MainRayGenShader()
{ 
    uint2 launchIndex = uint2(DispatchRaysIndex().x, DispatchRaysDimensions().y - DispatchRaysIndex().y - 1);
    uint2 launchDim = DispatchRaysDimensions().xy;

    // Shoot rays through the center of a pixel.
    float2 frameCoord = launchIndex + float2(0.5, 0.5);

    // Initial random number generator seed for this pixel. The rngState will change every time we draw a random number.
#ifdef USE_BLUENOISE_SAMPLING
    // Change sampling at each frame
    uint rngState = g_FrameIndex % 256;
    
    // Fixed sampling
    //uint rngState = 0;   
#else
    uint rngState = uint(uint(launchIndex.x) * uint(1973) + uint(launchIndex.y) * uint(9277) + uint(g_FrameIndex) * uint(26699)) | uint(1);   
#endif
    

    float2 ndcCoords = frameCoord  / float2(launchDim.x - 1, launchDim.y - 1);
        
    ndcCoords = ndcCoords * 2 - float2(1, 1);

    // Get a ray in view space.
    float3 viewDirection = normalize(float3(ndcCoords.x * g_AspectRatio * g_Zoom, ndcCoords.y * g_Zoom, 1));

    // Rotate the ray from view space to world space.
    float3 rayDirection = mul((float3x3)unity_CameraToWorld, viewDirection);

    uint missShaderIndex = 0;
    
    RayDesc ray;
    ray.Origin      = _WorldSpaceCameraPos;
    ray.Direction   = rayDirection;
    ray.TMin        = 0;
    ray.TMax        = K_T_MAX;
              
    RayPayload payload;
    payload.albedo                  = float3(1, 1, 1);
    payload.emission                = float3(0, 0, 0);
    payload.rngState                = rngState;
    payload.bounceIndexOpaque       = 0;
    payload.bounceIndexTransparent  = 0;
    payload.bounceRayOrigin         = float3(0, 0, 0);
    payload.bounceRayDirection      = float3(0, 0, 0);
    payload.lastWorldNormal         = float3(0, 0, 0);
    payload.k                       = 1;
    payload.isShadowRay             = false;

    // Safe net for when shaders have compilation errors and don't increase the bounce index, resulting in an infinite loop.
    uint safeNet = 0;

    float3 radiance = float3(0, 0, 0);
    float3 throughput = float3(1, 1, 1);
    float2 motionVector = float2(0, 0);

    do
    {
        TraceRay(g_AccelStruct, 0, 0xFF, 0, 1, missShaderIndex, ray, payload);

        // Accumulate emission from hit object
        radiance += payload.emission * throughput;
            
        throughput *= payload.albedo / max(0.001, payload.k);

#ifdef ENABLE_CAMERA_MOTION_VECTORS
        // TODO: this is not 100% correct yet, static camera does not give 0 vectors!
        if (payload.bounceIndexOpaque == 1)
        {
            float4 projCoords = mul(g_PreviousViewProjection, float4(payload.lastWorldPosition, 1.0));
            projCoords.xyz = projCoords.xyz / projCoords.w;
            projCoords.xy = (projCoords.xy * 0.5 + 0.5) * float2(launchDim.x - 1, launchDim.y - 1);
            motionVector = frameCoord - projCoords.xy;
        }
#endif
            
        if(g_UseDirectionalLight > 0)
        {
            // Directionnal light sampling
            RayDesc shadowRay;
            shadowRay.Origin      = payload.bounceRayOrigin;
            shadowRay.Direction   = -g_DirectionalLight.xyz;
            shadowRay.TMin        = 0;
            shadowRay.TMax        = K_T_MAX;

            RayPayload payLoadShadow;
            payLoadShadow.bounceIndexOpaque       = 0;
            payLoadShadow.emission                = float3(0,0,0);
            payLoadShadow.isShadowRay             = true;
                
            if(g_DirectionalLightShadows > 0)
            {
                // Trace shadow ray
                TraceRay(g_AccelStruct, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH, 0xFF, 0, 1, missShaderIndex, shadowRay, payLoadShadow);
            }
            else
            {
                payLoadShadow.bounceIndexOpaque = -1;
            }

            if(payLoadShadow.bounceIndexOpaque == -1)
            {
                radiance += saturate(dot(-g_DirectionalLight.xyz,payload.lastWorldNormal)) * g_DirectionalLightColor.xyz * throughput;
            }
        }

        float pathStopProbability = 1;

#define ENABLE_RUSSIAN_ROULETTE 1

#if ENABLE_RUSSIAN_ROULETTE
        pathStopProbability = max(throughput.r, max(throughput.g, throughput.b));

#ifdef USE_BLUENOISE_SAMPLING
        uint bounceNum = payload.bounceIndexOpaque + payload.bounceIndexTransparent;
        float randRR = GetBNDSequenceSample(launchIndex, 0, NB_RAND_BOUNCE * bounceNum + 3);
#else
        float randRR = RandomFloat01(payload.rngState);
#endif

        // Dark colors have higher chance to terminate the path early.
        if (pathStopProbability < randRR)
            break;
#endif

        throughput *= 1 / pathStopProbability;

        ray.Origin      = payload.bounceRayOrigin;
        ray.Direction   = payload.bounceRayDirection;
    }
    while ((payload.bounceIndexOpaque <= g_BounceCountOpaque) && (payload.bounceIndexTransparent <= g_BounceCountTransparent) && (++safeNet < 1000));  


#ifdef ENABLE_TEMPORAL_ACCUMULATION
    float alpha = 0.1;
    float2 projCoord = frameCoord - motionVector;
    if (projCoord.x < 0 || projCoord.y < 0 || projCoord.x > launchDim.x || projCoord.y > launchDim.y)
        alpha = 1.0;

    float3 prevRadiance = g_RadianceHistory.Load(projCoord).xyz;

    float3 result = lerp(prevRadiance, radiance, g_FrameIndex > 0 ? alpha : 1.0);
    g_Radiance[launchIndex] = float4(result, 1);
    g_RadianceHistory[launchIndex] = float4(result, 1);
#else
   g_Radiance[launchIndex] = float4(radiance, 1);
#endif
}

[shader("miss")]
void MainMissShader0(inout RayPayload payload : SV_RayPayload)
{
    payload.emission                = !payload.isShadowRay ? g_EnvTex.SampleLevel(sampler_g_EnvTex, WorldRayDirection(), 0).xyz : float3(0, 0, 0);
    payload.bounceIndexOpaque       = -1;
}
