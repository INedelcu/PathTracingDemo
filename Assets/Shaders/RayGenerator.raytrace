
#include "UnityShaderVariables.cginc"
#include "GlobalResources.hlsl"
#include "Utils.hlsl"
#include "RayPayload.hlsl"

#pragma max_recursion_depth 31

// Input
float                           g_Zoom;
float                           g_AspectRatio;
uint                            g_ConvergenceStep;
uint                            g_FrameIndex;
uint                            g_BounceCountOpaque;
uint                            g_BounceCountTransparent;
TextureCube<float4>             g_EnvTex;
SamplerState                    sampler_g_EnvTex;

// Output
RWTexture2D<float4>             g_Radiance;

[shader("raygeneration")]
void MainRayGenShader()
{ 
    uint2 launchIndex = uint2(DispatchRaysIndex().x, DispatchRaysDimensions().y - DispatchRaysIndex().y - 1);
    uint2 launchDim = DispatchRaysDimensions().xy;

    // Shoot rays through the center of a pixel (plus a jitter).
    float2 frameCoord = launchIndex + float2(0.5, 0.5);

    // Initial random number generator seed for this pixel. The rngState will change every time we draw a random number.
    uint rngState = uint(uint(launchIndex.x) * uint(1973) + uint(launchIndex.y) * uint(9277) + uint(g_ConvergenceStep + g_FrameIndex) * uint(26699)) | uint(1);
   
    float2 jitter = float2(RandomFloat01(rngState), RandomFloat01(rngState)) - float2(0.5, 0.5);

    float2 ndcCoords = (frameCoord + jitter) / float2(launchDim.x - 1, launchDim.y - 1);
        
    ndcCoords = ndcCoords * 2 - float2(1, 1);
    ndcCoords = ndcCoords * g_Zoom;

    // Get a ray in camera space.
    float3 viewDirection = normalize(float3(ndcCoords.x * g_AspectRatio, ndcCoords.y, 1));

    // Rotate the ray from view space to world space.
    float3 rayDirection = mul((float3x3)unity_CameraToWorld, viewDirection);
    
    RayDesc ray;
    ray.Origin      = _WorldSpaceCameraPos;
    ray.Direction   = rayDirection;
    ray.TMin        = 0;
    ray.TMax        = K_T_MAX;          
              
    RayPayload payload;
    payload.radiance                = float3(0, 0, 0);
    payload.throughput              = float3(1, 1, 1);
    payload.rngState                = rngState;
    payload.bounceCountOpaque       = g_BounceCountOpaque;
    payload.bounceCountTransparent  = g_BounceCountTransparent;
    
    uint missShaderIndex = 0;
    TraceRay(g_AccelStruct, 0, 0xFF, 0, 1, missShaderIndex, ray, payload);
}

[shader("callable")]
void WriteResult(inout Result result)
{
    uint2 launchIndex = uint2(DispatchRaysIndex().x, DispatchRaysDimensions().y - DispatchRaysIndex().y - 1);

    float3 prevRadiance = g_Radiance[launchIndex].xyz;

    float3 output = lerp(prevRadiance, result.radiance, 1 / float(g_ConvergenceStep + 1));

    g_Radiance[launchIndex] = float4(output, 1);
}

[shader("miss")]
void MainMissShader0(inout RayPayload payload : SV_RayPayload)
{
    Result result;

    // Env maps are HDR (linear space)
    result.radiance = payload.radiance + payload.throughput * g_EnvTex.SampleLevel(sampler_g_EnvTex, WorldRayDirection(), 0).xyz;

    CallShader(0, result);
}