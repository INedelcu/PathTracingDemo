#pragma kernel ATrousKernel

/* Edge-Avoiding A-Trous Wavelet Filter
   see: https://jo.dreggn.org/home/2010_atrous.pdf
*/

// kSamplerClampNearestUnormCoords for all of them.
Texture2D<float4> radiance; // Source buffer
Texture2D<float4> normals;
Texture2D<float> depths;
Texture2D<float> variance;// Prev variance buffer
RWTexture2D<float4> filteredRadiance; // Dest buffer

int2 imageSize;

float colSigma;
float normSigma;
float depthSigma;
int coordOffset;

#if !defined(BLOCK_SIZE)
#define BLOCK_SIZE 8
#endif

groupshared	float4 window[(BLOCK_SIZE + 2)*(BLOCK_SIZE + 2)];

// ----------------------------------------------------------------------------------------------------

#define REFLECT(x, max) \
   if (x < 0) x = - x - 1; \
   if (x >= max) x =  2 * max - x - 1;

// ----------------------------------------------------------------------------------------------------

void FILL_LOCAL_BUFFER_RADIANCE(int2 local_id, Texture2D<float4> radiance, int2 srcBufferSize, int2 coord, int halfWindow, inout int2 localStart)
{
      int localX = local_id.x; 
      int localY = local_id.y; 
      int beg = 0, end = 0; 
      int windowSize = (BLOCK_SIZE + halfWindow*2)*(BLOCK_SIZE + halfWindow*2); 
      int block = ceil((float)(windowSize) / (BLOCK_SIZE * BLOCK_SIZE)); 
      if (localX + localY*BLOCK_SIZE <= ceil((float)(windowSize) / block)) 
      { 
         beg = (localX + localY*BLOCK_SIZE)*block; 
         end = beg + block; 
         end = clamp(end, 0, windowSize); 
      } \
      localStart = (int2)((coord.x & (~(BLOCK_SIZE - 1))) - halfWindow, (coord.y & (~(BLOCK_SIZE - 1))) - halfWindow); 
      localStart = clamp(localStart, (int2)0, srcBufferSize - (int2)1); 
      for (int i = beg; i < end; ++i) 
      { 
         int2 xy = (int2)(localStart.x + (i % (BLOCK_SIZE + halfWindow*2)), localStart.y + (i / (BLOCK_SIZE + halfWindow*2))); 
         xy = clamp(xy, 0, srcBufferSize - (int2)1); 
         window[i] = radiance[xy]; 
      } 
      GroupMemoryBarrierWithGroupSync(); 
}

void FILL_LOCAL_BUFFER_NORMALS_DEPTH(int2 local_id, Texture2D<float4> normals, Texture2D<float> depths, int2 srcBufferSize, int2 coord, int halfWindow, inout int2 localStart)
{
   int localX = local_id.x; 
   int localY = local_id.y; 
   int beg = 0, end = 0; 
   int windowSize = (BLOCK_SIZE + halfWindow*2)*(BLOCK_SIZE + halfWindow*2); 
   int block = ceil((float)(windowSize) / (BLOCK_SIZE * BLOCK_SIZE)); 
   if (localX + localY*BLOCK_SIZE <= ceil((float)(windowSize) / block)) 
   { 
      beg = (localX + localY*BLOCK_SIZE)*block; 
      end = beg + block; 
      end = clamp(end, 0, windowSize); 
   } \
   localStart = (int2)((coord.x & (~(BLOCK_SIZE - 1))) - halfWindow, (coord.y & (~(BLOCK_SIZE - 1))) - halfWindow); 
   localStart = clamp(localStart, (int2)0, srcBufferSize - (int2)1); 
   for (int i = beg; i < end; ++i) 
   { 
      int2 xy = (int2)(localStart.x + (i % (BLOCK_SIZE + halfWindow*2)), localStart.y + (i / (BLOCK_SIZE + halfWindow*2))); 
      xy = clamp(xy, 0, srcBufferSize - (int2)1); 
      window[i].xyz = normals[xy].xyz;
      window[i].w = depths[xy];
   } 
   GroupMemoryBarrierWithGroupSync(); 
}

// ----------------------------------------------------------------------------------------------------

#define DERIVATE(buffer, bufferSize, coord, halfWindow, localStart, dFdX, dFdY) \
do \
{ \
   int left = clamp(coord.x - 1, 0, bufferSize.x - 1); \
   int right = clamp(coord.x + 1, 0, bufferSize.x - 1); \
   int top = clamp(coord.y - 1, 0, bufferSize.y - 1); \
   int bottom = clamp(coord.y + 1, 0, bufferSize.y - 1); \
   dFdX = (buffer[(left - localStart.x) + (BLOCK_SIZE + halfWindow*2)*(top - localStart.y)]  \
        - buffer[(right - localStart.x) + (BLOCK_SIZE + halfWindow*2)*(top - localStart.y)] \
        + 2 * (buffer[(left - localStart.x) + (BLOCK_SIZE + halfWindow*2)*(coord.y - localStart.y)]  \
               - buffer[(right - localStart.x) + (BLOCK_SIZE + halfWindow*2)*(coord.y - localStart.y)]) \
        + buffer[(left - localStart.x) + (BLOCK_SIZE + halfWindow*2)*(bottom - localStart.y)] \
        - buffer[(right - localStart.x) + (BLOCK_SIZE + halfWindow*2)*(bottom - localStart.y)]); \
   dFdY = (buffer[(left - localStart.x) + (BLOCK_SIZE + halfWindow*2)*(top - localStart.y)]  \
        - buffer[(left - localStart.x) + (BLOCK_SIZE + halfWindow*2)*(bottom - localStart.y)] \
        + 2 * (buffer[(coord.x - localStart.x) + (BLOCK_SIZE + halfWindow*2)*(top - localStart.y)]  \
               - buffer[(coord.x - localStart.x) + (BLOCK_SIZE + halfWindow*2)*(bottom - localStart.y)]) \
        + buffer[(right - localStart.x) + (BLOCK_SIZE + halfWindow*2)*(top - localStart.y)] \
        - buffer[(right - localStart.x) + (BLOCK_SIZE + halfWindow*2)*(bottom - localStart.y)]); \
} \
while(0);


// ----------------------------------------------------------------------------------------------------
// Similarity function
static inline float C(float3 x1, float3 x2, float sigma)
{
   float3 distance = x1 - x2;
   float a = length(distance) / sigma;
   return exp(-a);
}

// ----------------------------------------------------------------------------------------------------
// Depth similarity function
static inline float dW(float x1, float x2, float sigma)
{
   float a = abs(x1 - x2) / sigma;
   return exp(-a);
}

// ----------------------------------------------------------------------------------------------------
// Normals similarity function
static inline float nW(float3 x1, float3 x2, float sigma)
{
   x1 = normalize(x1 + float3(0.01f, 0.01f, 0.01f));
   x2 = normalize(x2 + float3(0.01f, 0.01f, 0.01f));
   float a = max((float)0.0f, dot(x1, x2));

   return pow(a, (float)1.0f / sigma);
}

// ----------------------------------------------------------------------------------------------------
static inline float4 SampleGauss3x3F(int2 local_id, Texture2D<float4> radiance, int2 buffer_size, int2 coord)
{
   int2 tl = clamp(coord - (int2)1, (int2)0, buffer_size - (int2)1);
   int2 br = clamp(coord + (int2)1, (int2)0, buffer_size - (int2)1);
   int2 localStart;

   FILL_LOCAL_BUFFER_RADIANCE(local_id, radiance, buffer_size, coord, 1, localStart);

   float4 bluredVal = 0.077847f * (
      window[(tl.x - localStart.x) + (BLOCK_SIZE + 2)*(tl.y - localStart.y)]
      + window[(br.x - localStart.x) + (BLOCK_SIZE + 2)*(tl.y - localStart.y)]
      + window[(tl.x - localStart.x) + (BLOCK_SIZE + 2)*(br.y - localStart.y)]
      + window[(br.x - localStart.x) + (BLOCK_SIZE + 2)*(br.y - localStart.y)] );

   bluredVal += 0.123317f * (
      window[(coord.x - localStart.x) + (BLOCK_SIZE + 2)*(tl.y - localStart.y)]
      + window[(br.x - localStart.x) + (BLOCK_SIZE + 2)*(coord.y - localStart.y)]
      + window[(tl.x - localStart.x) + (BLOCK_SIZE + 2)*(coord.y - localStart.y)]
      + window[(coord.x - localStart.x) + (BLOCK_SIZE + 2)*(br.y - localStart.y)] );

   bluredVal += 0.195346f * window[(coord.x - localStart.x) + (BLOCK_SIZE + 2)*(coord.y - localStart.y)];
   return bluredVal;
}

[numthreads(8,8,1)]
void ATrousKernel(
   uint3 global_id : SV_DispatchThreadID,
   uint3 local_id : SV_GroupThreadID)
{
   int2 coord = global_id.xy;

   float2 gradDpt = 0.0f;

   float4 dFdX, dFdY;
   int2 localStart;
   FILL_LOCAL_BUFFER_NORMALS_DEPTH(local_id.xy, normals, depths, imageSize, coord, 1, localStart);
   DERIVATE(window, imageSize, coord, 1, localStart, dFdX, dFdY);
   GroupMemoryBarrierWithGroupSync();

   gradDpt.x = dFdX.w;
   gradDpt.y = dFdY.w;

   // color variance value
#ifdef FIRST_PASS
   float colVar = length(float3(SampleGauss3x3F(local_id.xy, radiance, imageSize, coord, window).xyz));
#else
   float colVar = variance[coord];
#endif

   //B3 spline
   const float kernl[] =
   {
      1.0f / 256, 1.0f / 64, 3.0f / 128, 1.0f / 64, 1.0f / 256,
      1.0f / 64, 1.0f / 16, 3.0f / 32, 1.0f / 16, 1.0f / 64,
      3.0f / 128, 3.0f / 32, 9.0f / 64, 3.0f / 32, 3.0f / 128,
      1.0f / 64, 1.0f / 16, 3.0f / 32, 1.0f / 16, 1.0f / 64,
      1.0f / 256, 1.0f / 64, 3.0f / 128, 1.0f / 64, 1.0f / 256
   };

   // color value at the center of the window
   float4 temp = radiance[coord];
   float3 qcol = temp.xyz;
   const float srcAlpha = temp.w;

   // normal/depth value at the center of the window
   float3 qnorm = normals[coord].xyz;
   float qdpt   = depths[coord];

   float4 output = float4(0.0f,0.0f,0.0f,0.0f);
   float sum  = 0.0f;

   for (int i = -2; i <= 2; ++i)
      for (int j = -2; j <= 2; ++j)
      {
         int2 offsetUV;
         offsetUV.x = coord.x + i * coordOffset;
         offsetUV.y = coord.y + j * coordOffset;

         REFLECT(offsetUV.x, imageSize.x)
         REFLECT(offsetUV.y, imageSize.y)
         offsetUV.x = clamp(offsetUV.x, (int)0, (int)imageSize.x-1);
         offsetUV.y = clamp(offsetUV.y, (int)0, (int)imageSize.y-1);

         float coeff = kernl[i + 2 + (j + 2) * 5];

         float3 c = radiance[offsetUV].xyz;

         float multiplier = C(c, qcol, colSigma * sqrt(colVar) + 1.0e-5f);
         coeff *= multiplier > 0.0f ? multiplier : 0.0f;

         // Normal edge stopping
         float3 normal = normals[offsetUV].xyz;
         float depth   = depths[offsetUV];
         
         multiplier = nW(normal.xyz, qnorm, normSigma);
         coeff *= multiplier > 0.0f ? multiplier : 0.0f;

         // Depth edge stopping
         multiplier = dW(depth, qdpt, depthSigma * abs(dot(gradDpt, float2(i * coordOffset, j * coordOffset))) + 1.0e-3f);
         coeff *= multiplier > 0.0f ? multiplier : 0.0f;

         output.xyz += c * coeff;

         sum += coeff;
      }

   output.w   = srcAlpha;
   output.xyz = sum > float3(0.0f, 0.0f, 0.0f) ? output.xyz / sum : float3(0.0f, 0.0f, 0.0f);

   filteredRadiance[coord] = output;
}
